"""last modified: 04/07/202115-minute area finding codenote: uses l2 rather than crawling algorithm"""#%% packagesimport pandas as pdimport numpy as npimport osimport folium#%% importing data# path to dataamenities_path = '../datasets_clean/merged.csv'parcels_path = '../datasets_clean/parcels_latlon.csv'# note: amenities has lat, lon, category# note: parcels has lat, lon, zip# pulling data from csv fileif os.path.exists(amenities_path):    print('acquiring data (amenities))...')    amenities = pd.read_csv(amenities_path, usecols = [3,4,5])    # rejects if path has been changedelse:    raise FileNotFoundError('invalid path to merge')    # pulling data from csv file (parcels)if os.path.exists(parcels_path):    print('acquiring data (parcels)...')    parcels = pd.read_csv(parcels_path, usecols = [2,3,4])# rejects if path has been changedelse:    raise FileNotFoundError('invalid path to parcels')        #%% reducing redundant amenities, separating into categories# amenities closer than 0.00001 are essentially atop each otherreduced = amenities.round({'lat':5, 'lon':5})# separationcommercial = reduced[reduced['category'] == 'commercial']education = reduced[reduced['category'] == 'education']food = reduced[reduced['category'] == 'food']health = reduced[reduced['category'] == 'health']recreation = reduced[reduced['category'] == 'recreation']social = reduced[reduced['category'] == 'social']categories = [commercial, education, food, health, recreation, social]# removing equivalent data pointscommercial = commercial[~commercial.duplicated(subset = ['lat', 'lon'])]education = education[~education.duplicated(subset = ['lat', 'lon'])]food = food[~food.duplicated(subset = ['lat', 'lon'])]health = health[~health.duplicated(subset = ['lat', 'lon'])]recreation = recreation[~recreation.duplicated(subset = ['lat', 'lon'])]social = social[~social.duplicated(subset = ['lat', 'lon'])]#%% base mapprint('generating map of amenities...')base_path = 'maps/base_map.html'# function to generate base mapdef generate_base(default_location = [42.3150,-71.0700]):    base_map = folium.Map(location = default_location,                          zoom_start = 12,                          tiles = 'CartoDB positron')    return base_map# generating map with amenitiesbase = generate_base()# amenities and colorsamenity_list = [commercial, education, food, health, recreation, social]color_list = ['red', 'blue', 'green', 'purple', 'orange', 'darkred']# iterating over each amenityfor i in range(6):        # latitudes and longitudes as lists    latitudes = list(amenity_list[i].lat)    longitudes = list(amenity_list[i].lon)        color = color_list[i]        for lat, lon in zip(latitudes, longitudes):        folium.Circle(            location = [lat,lon],            radius = 10,            color = color,            fill = True,            weight = 1.5            ).add_to(base)    print('saving base map...')base.save(base_path)#%%base = generate_base()latitudes = list(education.lat)longitudes = list(education.lon)color = 'red'for lat, lon in zip(latitudes, longitudes):    folium.Circle(        location = [lat,lon],        radius = 10,        color = color,        fill = True,        weight = 1.5        ).add_to(base)    base.save('ex_map.html')#%% using l2 distance to approximate 15-minutesprint('finding close-by parcels...')# 15-minute walking distance in latitude/longitudelimit = 0.007# amenities and names; columns to useamenity_list = [social, commercial, education, food, health, recreation]name_list = ['social', 'commercial', 'education', 'food', 'health', 'recreation']cols = ['lat','lon']served = list(range(6))underserved = list(range(6))# iterate over amenitiesfor i in range(6):        print('finding closeness for:', name_list[i])        # initialize column for closenesses    parcels[name_list[i]] = 0        # latitudes and longitudes as lists    latitudes = list(amenity_list[i].lat)    longitudes = list(amenity_list[i].lon)        # for each amenity, find parcels within distance    for lat, lon in zip(latitudes, longitudes):                # dataframe with same lat and lon        amenity = pd.DataFrame(np.zeros((parcels.shape[0],2),                                        dtype=int),                                columns = cols)        amenity.lat = lat        amenity.lon = lon                # l2 distances        closeness = np.linalg.norm(amenity[cols].values - parcels[cols].values,                                    axis = 1)        closeness = pd.Series(closeness)                parcels[name_list[i]] = parcels[name_list[i]] + \            closeness.apply(lambda x: 1 if x < limit else 0)            underserved[i] = parcels[parcels[name_list[i]] == 0]    served[i] = parcels[parcels[name_list[i]] != 0]        served_map = generate_base()            for lat, lon in zip(underserved[i].lat.tolist(), underserved[i].lon.tolist()):        folium.Circle(            location = [lat,lon],            radius = 50,            color = 'red',            fill = True,            weight = 0,            fill_opacity = 0.7            ).add_to(served_map)            for lat, lon in zip(served[i].lat.tolist(), served[i].lon.tolist()):        folium.Circle(            location = [lat,lon],            radius = 50,            color = 'blue',            fill = True,            weight = 0,            fill_opacity = 0.7            ).add_to(served_map)            filename = 'maps/' + name_list[i] + '_map.html'        print('saving map for:', name_list[i])    served_map.save(filename)#%% outputprint('outputting data...')output_path = '../datasets_clean/results.csv'parcels.to_csv(output_path)print('done.')