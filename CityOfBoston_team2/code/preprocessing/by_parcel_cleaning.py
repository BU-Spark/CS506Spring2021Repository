"""date updated:  04/07/2021"""# copied from jupyter notebook map_parcel_preprocessingimport numpy as npimport pandas as pdparcels = pd.read_csv("../../dataset_ignore/Parcels_2020.csv",                      warn_bad_lines=False)property_assessment = pd.read_csv("../../dataset_ignore/property-assessment.csv",                                  warn_bad_lines=False)df = parcels.set_index("PID_LONG").join(property_assessment.set_index("PID"))df['ST_ADDR'] = df.apply(lambda row: ' '.join([s for s in row[['ST_NUM', 'ST_NAME', 'ST_NAME_SUF']] if s is not np.nan]), axis=1)df = df[['OWNER', 'XCOOR', 'YCOOR', 'ST_ADDR', 'ZIPCODE', 'PTYPE',]].rename(columns={'OWNER': 'NAME', 'XCOOR': 'LATITUDE', 'YCOOR': 'LONGITUDE'}).dropna(subset=['PTYPE']).astype({'ZIPCODE': 'int64', 'PTYPE': 'int64'}, errors='ignore')def map_amenity(ptype):    """Map PTYPE to essential amenity category, if applicable."""    if ptype in [904, *range(937, 944), 976, 977, 978]:        return 'Education'    if ptype in [*range(323, 329), 944]:        return 'Food access'    if ptype in [305, 953, 954, 979]:        return 'Healthcare'    if ptype in [*range(362, 365), *range(365, 378), *range(380, 385), 947, 984]:        return 'Recreation'    if ptype in [353, 945]:        return 'Social'    if ptype in range(300, 400):        return 'Commercial'        return np.nandf['CATEGORY'] = [map_amenity(parcel) for parcel in df['PTYPE']]df = df.drop('PTYPE', axis=1).dropna(subset=['CATEGORY'])# begin coordinate fixing#%% packagesfrom pyproj import Transformerimport pandas as pd#%% cleaningprint('cleaning dataframe...')parcels = df.copy(deep=True)# renamingparcels.columns = ['name', 'east', 'north', 'address', 'zip', 'category']parcels = parcels[['name', 'address', 'zip', 'east', 'north', 'category']]# removing na valuesparcels = parcels.dropna().reset_index(drop = True)#%% transforming to latitude and longitude wgs84print('converting coordinates...')# note epsg is massachusetts crs codetransformer = Transformer.from_crs(crs_from = 'epsg:2249',                                   crs_to = 'epsg:4326')# lists of east/north and initial for lat/loneast = list(parcels.east)north = list(parcels.north)latitudes = []longitudes = []# saving a couple entries for testingtest = parcels.loc[0:2,:].copy(deep = True)# transformingfor i in range(len(east)):    new = transformer.transform(east[i],north[i])    latitudes.append(new[0])    longitudes.append(new[1])# updating dataframeparcels.east = latitudesparcels.north = longitudes# checking first couple entriestest1 = transformer.transform(test.east[0],test.north[0])test2 = transformer.transform(test.east[1],test.north[1])test3 = transformer.transform(test.east[2],test.north[2])if test1 == (parcels.east[0],parcels.north[0]) and \    test2 == (parcels.east[1],parcels.north[1]) and \    test3 == (parcels.east[2],parcels.north[2]):        parcels.columns = ['name', 'address', 'zip', 'lat', 'lon', 'category']        print('converted.')        else:    print('improper conversion.')    #%% exportingprint('outputting...')output_path = '../../datasets_clean/p_businesses_latlon.csv'# output cleaned and converted data as csvparcels.to_csv(output_path)print('done')#%% visualizingimport foliumprint('generating map of parcels...')base_path = '../maps/p_businesses_map.html'# function to generate base mapdef generate_base(default_location = [42.3150,-71.0700]):    base_map = folium.Map(location = default_location,                          zoom_start = 12,                          tiles = 'CartoDB positron')    return base_map# latitudes and longitudes as listslatitudes = list(parcels.lat)longitudes = list(parcels.lon)# generating map with schoolsbase = generate_base()for lat, lon in zip(latitudes, longitudes):    folium.Circle(        location = [lat,lon],        radius = 20,        color = 'blue',        fill = True        ).add_to(base)for lat, lon in zip(latitudes, longitudes):    folium.Circle(        location = [parcels.lat[0],parcels.lon[0]],        radius = 20,        color = 'red',        fill = True        ).add_to(base)    base.save(base_path)