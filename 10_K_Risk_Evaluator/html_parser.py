#from nicks_module.py import his_func

from bs4 import BeautifulSoup, NavigableString, Tag
import requests


def import_data(html_file):
    """
    Convert an HTML file into a BeautifulSoup object.

    :param html_file: an HTML file.
    :return soup: a BeautifulSoup HTML tree.
    """
    with open(html_file) as f:
        soup = BeautifulSoup(f, 'lxml')
        return soup


def grab_section_text(soup_object, start_terms, end_terms):
    """
    Collect strings that are found within a specified section of an HTML tree.

    :param soup_object: an HTML tree generated by BeautifulSoup.
    :param start_terms: list of strings--should specify the upper boundary.
    :param end_terms: list of strings--should specify the lower boundary.
    :return section_text: list of strings found within specified 10-K section.
    """
    section_text = []  # Populated with text found in specified 10-K section
    within_item_1A = False
    for tag in soup_object.html.strings:  # Search each element in the tree

        if not within_item_1A:
            criteria = 0
            # String must contain "ITEM', '1A.', 'RISK', & 'FACTORS'
            for term in start_terms:
                if isinstance(tag, NavigableString):
                    if term in tag.upper():
                        criteria += 1
                elif isinstance(tag, Tag):
                    if term in tag.text.upper():
                        criteria += 1
            if criteria == len(start_terms):
                # Located the start of 'Item 1A: Risk Factors'
                within_item_1A = True
                section_text.append(tag)
                continue

        if within_item_1A:
            section_text.append(tag)  # Collect strings in section of interest
            criteria = 0
            # String must contain "ITEM', '1B.', 'UNRESOLVED', 'STAFF, & 'COMMENTS'
            for term in end_terms:
                if isinstance(tag, NavigableString):
                    if term in tag.upper():
                        criteria += 1
                elif isinstance(tag, Tag):
                    if term in tag.text.upper():
                        criteria += 1
            if criteria == len(end_terms):
                # Located the start of 'Item 1B: Unresolved Staff Comments'
                within_item_1A = False
                break
    return section_text


def remove_trivial_strings(input_list):
    """
    Remove whitespace or otherwise trivial lines from a list of strings.

    :param input_list: a list of strings.
    :return cleaned_list: a cleaned version of input_list.
    """
    misfits = ['â€¢', '\n', '\xa0']
    temp = [x for x in input_list if x not in misfits]  # Remove misfit lines
    temp = [i for n, i in enumerate(temp) if i not in temp[:n]]  # Rm duplicates
    cleaned_list = [item.strip() for item in temp]
    return cleaned_list



def summarize_risk(section):
    pass


def grab_tables():
    pass




def main(path):
    tree = import_data(str(path))  # Import html file

    # Specify a set of words that are unique to the boundaries of a section
    start_terms = ['ITEM', '1A.', 'RISK', 'FACTORS']
    end_terms = ['ITEM', '1B.', 'UNRESOLVED', 'STAFF', 'COMMENTS']

    risk_text = grab_section_text(tree, start_terms, end_terms)
    risk_text = remove_trivial_strings(risk_text)

    print(risk_text)
    print(len(risk_text))




#if __name__ == '__main__':
   # main()